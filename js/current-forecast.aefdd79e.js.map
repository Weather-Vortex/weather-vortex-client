{"version":3,"sources":["webpack:///./src/components/forecasts/CurrentForecast.vue?0c37","webpack:///src/components/forecasts/CurrentForecast.vue","webpack:///./src/components/forecasts/CurrentForecast.vue?66b7","webpack:///./src/components/forecasts/CurrentForecast.vue"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","fetching","forecasts","mid","staticRenderFns","name","components","computed","connected","loading","data","initialMidData","temp","tempMin","tempMax","pressure","humidity","clouds","rain","snow","midData","descriptions","Map","icons","provider","socket","status","waiting","methods","clean","JSON","parse","stringify","connect","subscribe","auth","disconnect","instance","off","requireForecasts","split","length","isNaN","latitude","longitude","console","log","emit","on","args","error","providers","forEach","warn","err","message","updateMid","keys","value","elem","populateMap","map","has","desc","set","increasedValue","getMostValueKeyFromMap","key","maxValueFromKey","keyWithMaxValue","mounted","beforeRouteLeave","from","to","next","destroyed","component","VCol","VContainer","VRow"],"mappings":"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","file":"js/current-forecast.aefdd79e.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('v-container',[_c('v-row',[_c('v-col',[_c('ForecastGroup',{attrs:{\"fetching\":_vm.fetching,\"initialForecasts\":_vm.forecasts,\"initialMid\":_vm.mid}})],1)],1)],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <v-container>\n    <v-row>\n      <v-col>\n        <ForecastGroup\n          v-bind:fetching=\"fetching\"\n          v-bind:initialForecasts=\"forecasts\"\n          v-bind:initialMid=\"mid\"\n        />\n      </v-col>\n    </v-row>\n  </v-container>\n</template>\n\n<script>\nimport create from \"@/socket\";\nimport ForecastGroup from \"@/components/weather/ForecastGroup\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport default {\n  name: \"CurrentForecast\",\n  components: { ForecastGroup },\n  computed: {\n    connected: function () {\n      return (\n        typeof this.socket !== \"undefined\" &&\n        this.socket !== null &&\n        this.socket.connected\n      );\n    },\n    loading: function () {\n      return this.fetching > 0;\n    },\n  },\n  data() {\n    return {\n      fetching: 0,\n      forecasts: [],\n      initialMidData: {\n        temp: 0,\n        tempMin: 0,\n        tempMax: 0,\n        pressure: 0,\n        humidity: 0,\n        clouds: 0,\n        rain: 0,\n        snow: 0,\n      },\n      midData: {},\n      descriptions: new Map(),\n      icons: new Map(),\n      mid: {\n        provider: \"Aggregated\",\n        data: {},\n      },\n      socket: null,\n      status: null,\n      waiting: [],\n    };\n  },\n  methods: {\n    clean: function () {\n      this.forecasts = [];\n      this.waiting = [];\n      this.mid.data = JSON.parse(JSON.stringify(this.initialMidData));\n      this.midData = JSON.parse(JSON.stringify(this.initialMidData));\n      // Needs to be two separated maps.\n      this.descriptions = new Map();\n      this.icons = new Map();\n    },\n    connect: function () {\n      const username = uuidv4();\n      this.socket = create();\n      this.subscribe();\n      this.socket.auth = { username };\n      this.socket.connect({ forceNew: true });\n    },\n    disconnect: function () {\n      const instance = this.socket;\n      instance.off(\"connection\");\n      instance.off(\"connect_error\");\n      instance.off(\"forecast_requested\");\n      instance.off(\"result\");\n      // state. socket.disconnect();\n      // this.$socket.close();\n      instance.disconnect();\n      this.socket = null;\n    },\n    requireForecasts: function (locality) {\n      this.fetching = this.fetching + 1;\n      this.clean();\n      const split = locality.split(\",\");\n      if (split && split.length === 2) {\n        const latitude = new Number(split[0]);\n        const longitude = new Number(split[1]);\n        if (!isNaN(latitude) && !isNaN(longitude)) {\n          console.log(\"Requiring %d::%d\", latitude, longitude);\n          this.socket.emit(\"current\", { latitude, longitude });\n          return;\n        }\n      }\n      this.socket.emit(\"current\", { locality });\n    },\n    subscribe: function () {\n      this.socket.on(\"connect\", () => {\n        // Now we can require forecasts to our server and listen to future results.\n        console.log(\"Socket Connected\");\n        const locality = this.$route.params.locality;\n        this.requireForecasts(locality);\n      });\n\n      this.socket.on(\"forecast_requested\", (args) => {\n        console.log(\"Args:\", args);\n        if (typeof args.providers !== \"object\") {\n          console.error(\"Received a corrupted packet from socket\");\n          this.fetching = this.fetching - 1;\n          return;\n        }\n\n        args.providers.forEach((provider) => {\n          this.waiting.push({ provider: provider });\n        });\n\n        this.fetching = this.fetching + args.providers.length - 1;\n      });\n\n      this.socket.on(\"connect_error\", (err) => {\n        console.warn(\"Connection error:\", err);\n        if (err.message === \"Invalid locality\") {\n          this.selectedLocality = false;\n        }\n      });\n\n      this.socket.on(\"result\", (result) => {\n        const { provider, data } = result;\n        console.log(\"Result from %s with %o:\", provider, data);\n        this.fetching = this.fetching - 1;\n        const current = this.waiting.filter(\n          (forecast) => forecast.provider !== provider\n        );\n        this.waiting = current;\n        this.forecasts.push({ provider, data });\n        this.updateMid(data);\n      });\n    },\n    updateMid: function (data) {\n      const keys = Object.keys(data);\n      keys.forEach((elem) => {\n        const value = Number(data[elem]);\n        // time and weather icons are not considered.\n        if (isNaN(value)) {\n          const desc = data[elem];\n          if (elem === \"weatherDescription\") {\n            // Update weather description map.\n            this.populateMap(desc, this.descriptions);\n            const keyWithMaxValue = this.getMostValueKeyFromMap(\n              this.descriptions\n            );\n            this.mid.data.weatherDescription = keyWithMaxValue;\n          } else if (elem === \"weatherIcon\") {\n            // Update weather icon map.\n            this.populateMap(desc, this.icons);\n            const keyWithMaxValue = this.getMostValueKeyFromMap(this.icons);\n            this.mid.data.weatherIcon = keyWithMaxValue;\n          }\n        } else {\n          this.midData[elem] += value;\n          const num = this.midData[elem] / this.forecasts.length;\n          const fixed = Number.parseFloat(num).toFixed(2);\n          this.mid.data[elem] = fixed;\n        }\n      });\n    },\n    populateMap: function (desc, map) {\n      if (map.has(desc)) {\n        const actualValue = map.get(desc);\n        const increasedValue = actualValue + 1;\n        map.set(desc, increasedValue);\n      } else {\n        map.set(desc, 1);\n      }\n    },\n    getMostValueKeyFromMap: function (map) {\n      let keyWithMaxValue = null;\n      let maxValueFromKey = 0;\n      map.forEach(function (value, key) {\n        if (maxValueFromKey < value) {\n          keyWithMaxValue = key;\n          maxValueFromKey = value;\n        }\n      });\n      return keyWithMaxValue;\n    },\n  },\n  mounted() {\n    if (!this.connected) {\n      this.connect();\n    }\n  },\n  beforeRouteLeave(to, from, next) {\n    console.log(\"Before route leave from %s to %s\", from, to);\n    if (this.connected) {\n      this.disconnect();\n    }\n    next();\n  },\n  destroyed() {\n    if (this.connected) {\n      this.disconnect();\n    }\n  },\n};\n</script>\n","import mod from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CurrentForecast.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CurrentForecast.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./CurrentForecast.vue?vue&type=template&id=2b0aadf2&\"\nimport script from \"./CurrentForecast.vue?vue&type=script&lang=js&\"\nexport * from \"./CurrentForecast.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports\n\n/* vuetify-loader */\nimport installComponents from \"!../../../node_modules/vuetify-loader/lib/runtime/installComponents.js\"\nimport { VCol } from 'vuetify/lib/components/VGrid';\nimport { VContainer } from 'vuetify/lib/components/VGrid';\nimport { VRow } from 'vuetify/lib/components/VGrid';\ninstallComponents(component, {VCol,VContainer,VRow})\n"],"sourceRoot":""}